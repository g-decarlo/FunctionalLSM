#' Plot LSM
#' 
#' @description generate various plots in order to better visualize the model built 
#' @param model an object returned by findsolutions.lsm
#' @param a the object returned by findanchorpoints.lsm used to generate the model
#' @param n_points a parameter proportional to the number of points generated to visualize the model
#' @param seed if points_arrangement is set to 'random', the seed used to generate the random points around each anchorpoints
#' @param points_arrangement arrangement of the points around each anchorpoints. "random" generates n_points random points in the 
#' neighbourhood of each anchor point; "straight" generates n_points*n_points equally spaced points in the neighbourhood of each anchor point
#' @param n_threads the number of threads for OpenMP, by default is equal to -1, which means that OpenMP will use all the available threads.
#' @param kriging if set to FALSE suppress the computation and the plot of the kriging; by default is FALSE
#' @param ellipse_scale how much the ellipses should be scaled in the plot compared to the default dimension
#' @param arrow_scale how much the arrows should be scaled in the plot compared to the default dimension
#' @return a dataframe containing the coordinates, the values of the parameters and the kriging of all the points generated by the function
#' @details given the final solutions of the analysis, this function allows to visualize all the steps done by providing
#' a bubble plot of the initial data, a pair of plots with the anisotropy ellipses and directions, 
# 'a plot with the values of lambda1, lambda2, phi and sigma in the plane and 
#' two plots with the values of the mean and punctual value of z predicted.
#' @examples
#' data(meuse)
#' d <- cbind(meuse$x, meuse$y)
#' y <- meuse$elev
#' a <- find_anchorpoints.lsm(d,12,FALSE)
#' vario <- variogram.lsm(y,d,a$anchorpoints,370,8,8,"gaussian")
#' solu <- findsolutions.lsm(vario, "exponential", c(200,200,0.01,100))
#' mypoints<-plot.lsm(model = solu, a = a, z = y, d = d, n_points = 3, points_arrangement = "straight", kriging = TRUE, ellipse_scale = 2, arrow_scale = 1.5)
plot.lsm<-function(model, a , z = model$initial_z, d, n_points = 3, seed = 68, points_arrangement = "straight", n_threads = -1, kriging = FALSE, ellipse_scale = 1, arrow_scale = 1)
{
  d <- model$initial_coordinates
  #z <- model$initial_z
  # set the seed
  if(points_arrangement == "random")
  {
    set.seed(seed = seed)
  }
  # associate each anchorpoints with the value of the parameters lambda1, lambda2, phi and sigma in its position
  aa <- as.data.frame(model$anchorpoints)
  
  colnames(aa) <- c("X","Y")
  s <- model$solutions
  s <- as.data.frame(s)
  colnames(s) <- c("lambda1", "lambda2", "phi", "sigma")
  g <- cbind(aa,s)
  
  # create a new dataframe to better visualize the model in the space
  # if points_arrangement = "random", generate n_points equally spaced in the angular domain at random distance (< a$width) from each anchorpoint
  # if points_arrangement = "straight", generate n_points*n_points equally spaced on straight lines around each anchorpoint
  newpoints <- data.frame(X = double(), Y = double())
  if (points_arrangement == "random")
  {
    for (i in 1:dim(g)[1])
    {
      for (j in 1:n_points)
      {
        radius <- a$width*runif(1, min=0, max=1)
        newpoints <- rbind(newpoints, c(g$X[i]+radius*cos(j*2*pi/n_points), g$Y[i]+radius*sin(j*2*pi/n_points)))
      }
    }
  }
  else if (points_arrangement == "straight")
  {
    for (i in 1:n_points)
    {
      vstep <- a$height/(n_points)
      for (j in 1:n_points)
      {
        hstep <- a$width/(n_points)
        newpoints <- rbind(newpoints, cbind(g$X-a$width+hstep*j-hstep/2, g$Y+a$height-vstep*i-vstep/2))
      }
    }
  }
  else
  {
    stop("points_arrangement is not a valid arrangement of points")
  }
  
  colnames(newpoints)<-c("X","Y")
  
  parameters<-smoothing(model$solutions,model$anchorpoints,model$delta,as.matrix(newpoints),model$kernel_id,n_threads)
  parameters<-as.data.frame(parameters)
  colnames(parameters)<-c("lambda1", "lambda2", "phi", "sigma")
  
  allpoints<-cbind(newpoints, parameters)
  
  # bubble plot of the initial data
  dd <- as.data.frame(d)
  colnames(dd) <- c("X", "Y")
  
  par(ask=TRUE)
  if (dim(z)[2] > 1){
  for(i in 1:dim(z)[2]){
    Z=z[,i]
    p <- ggplot2::ggplot(dd, ggplot2::aes(x=X, y=Y, size=Z)) + ggplot2::geom_point() + ggplot2::labs(x="X", y="Y")
    p <- p + ggplot2::labs(title = paste("Bubble plot of the initial data",as.character(i)), fontface = 'bold') + ggplot2::theme_light() + ggplot2::coord_fixed()
    print(p)
  }
  }
  else {
    Z=z
    p <- ggplot2::ggplot(dd, ggplot2::aes(x=X, y=Y, size=Z)) + ggplot2::geom_point() + ggplot2::labs(x="X", y="Y")
    p <- p + ggplot2::labs(title = "Bubble plot of the initial data", fontface = 'bold') + ggplot2::theme_light() + ggplot2::coord_fixed()
    print(p)
  }
  
  
  # ellipses and phi
  ellissi<-g
  if (max(ellissi$lambda1) > max(ellissi$lambda2))
  {
    r <- a$width/ellipse_scale
    ellissi$lambda1 <- ellissi$lambda2/(ellissi$lambda1/r)
    ellissi$lambda2 <- r
  }
  else
  {
    r <- a$height/ellipse_scale
    ellissi$lambda2 <- ellissi$lambda1/(ellissi$lambda2/r)
    ellissi$lambda1 <- r
  }
  p1 <- ggplot2::ggplot(ellissi, ggplot2::aes(x=X, y=Y)) + ggforce::geom_ellipse(ggplot2::aes(x0 = X, y0 = Y, a = lambda1, b = lambda2, angle = phi), data = ellissi) + ggplot2::coord_fixed() + ggplot2::theme_light()
  p2 <- ggplot2::ggplot(ellissi, ggplot2::aes(x=X, y=Y)) + ggplot2::geom_segment(ggplot2::aes(x=X, y=Y, xend=X+a$width*cos(phi)/arrow_scale, yend=Y+a$width*sin(phi)/arrow_scale), arrow = ggplot2::arrow(length = ggplot2::unit(2/arrow_scale, "mm")), data = ellissi)
  p2 <- p2 + ggplot2::geom_segment(ggplot2::aes(x=X, y=Y, xend=X-a$width*cos(phi)/arrow_scale, yend=Y-a$width*sin(phi)/arrow_scale), arrow = ggplot2::arrow(length = ggplot2::unit(2/arrow_scale, "mm")), data = ellissi) + ggplot2::coord_fixed() + ggplot2::theme_light()
  print(cowplot::plot_grid(p1, p2))
  
  # parameters
  if (points_arrangement == "random")
  {
    p1 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, color=lambda1)) + ggplot2::geom_point() + ggplot2::scale_color_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
    p2 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, color=lambda2)) + ggplot2::geom_point() + ggplot2::scale_color_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
    p3 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, color=phi)) + ggplot2::geom_point() + ggplot2::scale_color_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
    p4 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, color=sigma)) + ggplot2::geom_point() + ggplot2::scale_color_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
  }
  else
  {
    p1 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, fill=lambda1)) + ggplot2::geom_tile() + ggplot2::scale_fill_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
    p2 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, fill=lambda2)) + ggplot2::geom_tile() + ggplot2::scale_fill_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
    p3 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, fill=phi)) + ggplot2::geom_tile() + ggplot2::scale_fill_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
    p4 <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, fill=sigma)) + ggplot2::geom_tile() + ggplot2::scale_fill_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light()
  }
  title <- cowplot::ggdraw() + cowplot::draw_label("Parameters", fontface='bold')
  p <- cowplot::plot_grid(p1,p2,p3,p4)
  print(cowplot::plot_grid(title, p, ncol=1, rel_heights=c(0.1, 1)))
  
  if(kriging)
  { 
    # predict and plot the mean and punctual value of z for each newpoint
    predictedvalues<-predikt(as.matrix(z),d,model$anchorpoints,model$epsilon,model$delta,model$dim,model$solutions,as.matrix(allpoints)[,1:2],model$id,model$kernel_id,FALSE,n_threads,TRUE)
    for(i in 1:dim(predictedvalues$zpredicted)[2]){
    if (points_arrangement == "random")
    {
      means <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, color=predictedvalues$smoothed_means[,i])) + ggplot2::geom_point() + ggplot2::scale_color_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed()
      ys <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, color=predictedvalues$zpredicted[,i])) + ggplot2::geom_point() + ggplot2::scale_color_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed()
    }
    else
    {
      means <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, fill=predictedvalues$smoothed_means[,i])) + ggplot2::geom_tile() + ggplot2::scale_fill_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed()
      ys <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, fill=predictedvalues$zpredicted[,i])) + ggplot2::geom_tile() + ggplot2::scale_fill_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed()
    }
    means<-means+ggplot2::labs(fill="mean") + ggplot2::theme_light()
    ys<-ys+ggplot2::labs(fill="z") + ggplot2::theme_light()
    title <- cowplot::ggdraw() + cowplot::draw_label(paste("Predicted mean and z -",as.character(i)), fontface='bold')
    p <- cowplot::plot_grid(means, ys)
    print(cowplot::plot_grid(title, p, ncol=1, rel_heights=c(0.1, 1)))
    }
    allpoints <- cbind(allpoints, predictedvalues$smoothed_means)
    allpoints <- cbind(allpoints, predictedvalues$zpredicted)
    allpoints <- cbind(allpoints, predictedvalues$krigingvariance)
    colnames(allpoints)[7:9] <- c("smoothed_means", "zpredicted", "krigingvariance")
  }
  par(ask=FALSE)
  
  return(allpoints)
}

#' Plot parameters
#' 
#' @description sequential plot of all the paramters obtained by smoothing
#' @param allpoints a dataframe containing the coordinates and the value of the parameters
#' @details given a dataframe containing the coordinates and the value of the parameters for a set of points
#' this functions provides the plot in the plane of the trend of all the parameters. You can use this function, for example, with
#' the dataframe returned by plot.lsm to visualize other parameters from the four that are already plot by the previous function
#' @examples 
#' data(meuse)
#' d <- cbind(meuse$x, meuse$y)
#' y <- meuse$elev
#' a <- find_anchorpoints.lsm(d,12,FALSE)
#' vario <- variogram.lsm(y,d,a$anchorpoints,370,8,8,"gaussian")
#' solu <- findsolutions.lsm(vario, "exponential", c(200,200,0.01,100))
#' mypoints<-plot.lsm(model = solu, a = a, z = y, d = d, n_points = 3, points_arrangement = "straight", kriging = FALSE, ellipse_scale = 2, arrow_scale = 1.5)
#' plot.parameters(mypoints)
plot.parameters<-function(allpoints)
{
  for (i in 3:dim(allpoints)[2])
  {
    par(ask=TRUE)
    p <- ggplot2::ggplot(allpoints, ggplot2::aes(x=X, y=Y, color=allpoints[,i])) + ggplot2::geom_point() + ggplot2::scale_color_gradientn(colours = rainbow(5)) + ggplot2::coord_fixed() + ggplot2::theme_light() + ggplot2::labs(color = colnames(allpoints)[i])
    print(p)
  }
}

#' Plot Grid
#' 
#' @description  A function to plot segments for all pairs of locations belonging to the same vector neighborhood.        
#' @param variogram an object of type "sample_variogram" built via variogram.lsm
#' @param index  the index of the vector neighborhood for which segments are going to be plotted.
#' @examples
#' data(meuse)
#' d <- cbind(meuse$x, meuse$y)
#' y <- meuse$elev
#' a <- find_anchorpoints.lsm(d,12,FALSE)
#' vario <- variogram.lsm(y,d,a$anchorpoints,370,8,8,"gaussian")
#' plotgrid(vario, 0)
plotgrid<-function(variogram, index){
  d <- variogram$initial_coordinates
  grid <- variogram$grid
  plot(d,xlab="Latitude",ylab="Longitude")
  grid=as.data.frame(grid)
  
  for (i in 1:dim(d)[1]){
    for (j in i:dim(d)[1]){
      
      if(grid[i,j]==index){
        segments(d[i,1],d[i,2],d[j,1],d[j,2])
      }
    }
  }
}

#' Plot Vario
#' 
#' @description plot all directional empiric variograms sequentially in n_angles number of directions, from -pi to pi in radians.
#' @param variogram  a variogram object returned by variogram.lsm
#' @param pos the index of an anchor point where the empiric variogram is plotted
#' @examples 
#' data(meuse)
#' d <- cbind(meuse$x, meuse$y)
#' y <- meuse$elev
#' a <- find_anchorpoints.lsm(d,12,FALSE)
#' vario <- variogram.lsm(y,d,a$anchorpoints,370,8,8,"gaussian")
#' pltovario(vario, 0)
plotvario<-function(variogram, pos){
  n_angles <- variogram$n_angles
  n_intervals <- variogram$n_intervals
  epsilon <- variogram$epsilon
  empvariogram <- variogram$empiricvariogram
  b=2*epsilon
  diminterval = b/n_intervals
  
  coordnormh = numeric(n_intervals)
  for ( i in 1:n_intervals){
    coordnormh[i] = diminterval/2 + (i-1)*diminterval
  }
  
  par(ask=TRUE)
  for (i in 1:n_angles){
    plot(coordnormh , empvariogram[(n_intervals*(i-1)+1):(n_intervals*i),pos] , xlab=paste("Distance",
                                                                                           "  (",
                                                                                           as.character((180*(i-1))/n_angles-90),"\u00B0 :",
                                                                                           as.character((180*i)/n_angles-90),"\u00B0 )"),
         ylab= paste("Empiric Anisotropic Variogram"))
  }
}



